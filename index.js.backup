#!/usr/bin/env node

import { Command } from "commander";
import fs from "fs";
import path from "path";
import chalk from "chalk";
import inquirer from "inquirer";

const program = new Command();

// FunÃ§Ã£o para modo interativo
async function interactiveMode() {
  console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
  console.log(chalk.cyan('â•‘'), chalk.bold.white('ğŸ¯ Modo Interativo - Criador de Componentes').padEnd(58), chalk.cyan('â•‘'));
  console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
  console.log();
  
  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'nome',
      message: 'ğŸ“ Qual o nome do componente?',
      validate: (input) => {
        if (!input || input.trim() === '') {
          return 'âŒ O nome do componente Ã© obrigatÃ³rio!';
        }
        if (!/^[A-Z][a-zA-Z0-9]*$/.test(input.trim())) {
          return 'âŒ O nome deve comeÃ§ar com letra maiÃºscula e conter apenas letras e nÃºmeros!';
        }
        return true;
      }
    },
    {
      type: 'input',
      name: 'path',
      message: 'ğŸ“ Em qual pasta criar o componente? (Enter para raiz)',
      default: '.',
      validate: (input) => {
        // ValidaÃ§Ã£o bÃ¡sica de caminho
        if (input.includes('..') && !input.startsWith('./')) {
          return 'âŒ Use caminhos relativos que comecem com "./"';
        }
        return true;
      }
    },
    {
      type: 'confirm',
      name: 'useTypeScript',
      message: 'ğŸ”· Usar TypeScript?',
      default: false
    },
    {
      type: 'list',
      name: 'styleType',
      message: 'ğŸ¨ Qual tipo de estilizaÃ§Ã£o usar?',
      choices: [
        { name: 'ğŸ“„ CSS tradicional', value: 'css' },
        { name: 'ğŸ’… Styled Components', value: 'styled' },
        { name: 'ğŸ˜Š Emotion', value: 'emotion' }
      ],
      default: 'css'
    },
    {
      type: 'confirm',
      name: 'includeTests',
      message: 'ğŸ§ª Incluir arquivo de testes?',
      default: false
    }
  ]);

  return {
    nome: answers.nome.trim(),
    ts: answers.useTypeScript,
    styled: answers.styleType === 'styled',
    emotion: answers.styleType === 'emotion',
    path: answers.path,
    test: answers.includeTests
  };
}

program
  .name("create-component")
  .description("ğŸš€ CLI para gerar componentes React com suporte a CSS, Styled Components, Emotion e testes")
  .version("1.0.0")
  .helpOption('-h, --help', 'mostrar informaÃ§Ãµes de ajuda');

program
  .argument("[nome]", "Nome do componente (opcional no modo interativo)")
  .option("-t, --ts", "Gerar componente em TypeScript", false)
  .option("-s, --styled", "Gerar arquivo de styled components", false)
  .option("-e, --emotion", "Gerar arquivo de emotion styled", false)
  .option("-p, --path <caminho>", "Caminho onde criar o componente (padrÃ£o: diretÃ³rio atual)", ".")
  .option("-i, --interactive", "Modo interativo com perguntas", false)
  .option("--test", "Gerar arquivo de teste", false)
  .addHelpText('before', `
${chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')}
${chalk.cyan('â•‘')}  ${chalk.bold.white('ğŸ¨ CLI React Components Generator')}                           ${chalk.cyan('â•‘')}
${chalk.cyan('â•‘')}  ${chalk.gray('Ferramenta para criar componentes React rapidamente')}         ${chalk.cyan('â•‘')}
${chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')}
`)
  .addHelpText('after', `
${chalk.yellow('ğŸ’¡ EXEMPLOS DE USO:')}
  ${chalk.green('$')} ${chalk.white('create-component --interactive')}            ${chalk.gray('# ğŸ¯ Modo interativo com perguntas')}
  ${chalk.green('$')} ${chalk.white('create-component -i')}                       ${chalk.gray('# ğŸ¯ Modo interativo (alias)')}
  ${chalk.green('$')} ${chalk.white('create-component Button')}                    ${chalk.gray('# ğŸ“„ Componente bÃ¡sico na raiz')}
  ${chalk.green('$')} ${chalk.white('create-component Modal --ts')}                ${chalk.gray('# ğŸ”· Componente TypeScript')}
  ${chalk.green('$')} ${chalk.white('create-component Header --styled')}           ${chalk.gray('# ğŸ’… Componente com Styled Components')}
  ${chalk.green('$')} ${chalk.white('create-component Sidebar --emotion')}         ${chalk.gray('# ğŸ˜Š Componente com Emotion')}
  ${chalk.green('$')} ${chalk.white('create-component Card --path ./src')}         ${chalk.gray('# ğŸ“ Criar em pasta especÃ­fica')}
  ${chalk.green('$')} ${chalk.white('create-component Nav -p ./src/components')}   ${chalk.gray('# ğŸ“ Usar alias -p')}
  ${chalk.green('$')} ${chalk.white('create-component Form --ts --test --path ./src/forms')} ${chalk.gray('# ğŸš€ Completo com caminho')}

${chalk.yellow('ğŸ“ ESTRUTURAS DE CAMINHO:')}
  ${chalk.blue('Sem --path:')}       ${chalk.white('./NomeComponente/')} ${chalk.gray('(na raiz do projeto)')}
  ${chalk.blue('--path ./src:')}     ${chalk.white('./src/NomeComponente/')} ${chalk.gray('(dentro de src)')}
  ${chalk.blue('--path ./components:')} ${chalk.white('./components/NomeComponente/')} ${chalk.gray('(dentro de components)')}
  ${chalk.blue('Caminhos relativos:')} ${chalk.gray('Sempre relativos ao diretÃ³rio atual')}

${chalk.yellow('ğŸ“ ESTRUTURAS GERADAS:')}
  ${chalk.blue('BÃ¡sico:')}           ${chalk.white('NomeComponente/')} ${chalk.gray('NomeComponente.jsx + NomeComponente.css + index.js')}
  ${chalk.blue('--styled:')}         ${chalk.white('NomeComponente/')} ${chalk.gray('NomeComponente.jsx + styled.js + index.js')}
  ${chalk.blue('--emotion:')}        ${chalk.white('NomeComponente/')} ${chalk.gray('NomeComponente.jsx + styles.js + index.js')}
  ${chalk.blue('--test:')}           ${chalk.gray('Adiciona')} ${chalk.white('NomeComponente.test.jsx')} ${chalk.gray('com testes bÃ¡sicos')}
  ${chalk.blue('--ts:')}             ${chalk.gray('Usa extensÃµes')} ${chalk.white('.tsx/.ts')} ${chalk.gray('em vez de')} ${chalk.white('.jsx/.js')}

${chalk.yellow('âš ï¸  NOTAS IMPORTANTES:')}
  ${chalk.red('â€¢')} NÃ£o Ã© possÃ­vel usar ${chalk.white('--styled')} e ${chalk.white('--emotion')} juntos
  ${chalk.green('â€¢')} Cada componente Ã© criado em sua prÃ³pria pasta
  ${chalk.green('â€¢')} Arquivo ${chalk.white('index.js/ts')} Ã© sempre criado para facilitar importaÃ§Ãµes
  ${chalk.green('â€¢')} Caminhos sÃ£o criados automaticamente se nÃ£o existirem
  ${chalk.green('â€¢')} TypeScript (${chalk.white('--ts')}) funciona com todas as outras opÃ§Ãµes

${chalk.cyan('ğŸ”— Para mais informaÃ§Ãµes, visite:')} ${chalk.underline('https://github.com/seu-usuario/cli-react-components')}
`)
  .action(async (nome, options) => {
    let componentOptions;
    
    // Se modo interativo ou nÃ£o hÃ¡ nome fornecido
    if (options.interactive || !nome) {
      componentOptions = await interactiveMode();
    } else {
      // Modo tradicional via flags
      // Verificar se o nome foi fornecido
      if (!nome || nome.trim() === '') {
        console.log(chalk.red.bold("âŒ ERRO:"), chalk.red("Nome do componente Ã© obrigatÃ³rio"));
        console.log(chalk.gray("ğŸ’¡ Use"), chalk.cyan("'create-component --help'"), chalk.gray("para ver todas as opÃ§Ãµes"));
        console.log(chalk.gray("ğŸ’¡ Ou use"), chalk.cyan("'create-component --interactive'"), chalk.gray("para modo interativo"));
        return;
      }
      
      componentOptions = {
        nome: nome.trim(),
        ts: options.ts,
        styled: options.styled,
        emotion: options.emotion,
        path: options.path,
        test: options.test
      };
    }

    // Agora criar o componente com as opÃ§Ãµes escolhidas
    await createComponent(componentOptions);
  });

// FunÃ§Ã£o para criar o componente
async function createComponent(options) {
    const { nome, ts, styled, emotion, path: customPath, test } = options;
    
    const ext = ts ? "tsx" : "jsx";
    const jsExt = ts ? "ts" : "js";
    
    // Resolver o caminho base (onde criar o componente)
    const basePath = path.resolve(process.cwd(), customPath || ".");
    const dir = path.join(basePath, nome);
    
    // Criar diretÃ³rios recursivamente se nÃ£o existirem
    if (!fs.existsSync(basePath)) {
      fs.mkdirSync(basePath, { recursive: true });
      console.log(chalk.blue("ğŸ“"), chalk.bold("DiretÃ³rio criado:"), chalk.gray(basePath));
    }
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Verificar se styled e emotion foram usados juntos
    if (styled && emotion) {
      console.log(chalk.red.bold("âŒ ERRO:"), chalk.red("NÃ£o Ã© possÃ­vel usar"), chalk.yellow("styled"), chalk.red("e"), chalk.yellow("emotion"), chalk.red("juntos."));
      console.log(chalk.gray("ğŸ’¡ Escolha apenas uma das opÃ§Ãµes de estilizaÃ§Ã£o."));
      return;
    }

    // Banner de inÃ­cio
    console.log(chalk.cyan('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(chalk.cyan('â•‘'), chalk.bold.white(`ğŸ¨ Criando componente: ${nome}`).padEnd(58), chalk.cyan('â•‘'));
    
    // Mostrar o caminho onde serÃ¡ criado
    const relativePath = path.relative(process.cwd(), dir);
    console.log(chalk.cyan('â•‘'), chalk.gray(`ğŸ“ Caminho: ${relativePath}`).padEnd(58), chalk.cyan('â•‘'));
    console.log(chalk.cyan('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    console.log();

    // Template do componente principal
    let componentImports = `import React from "react";\n`;
    let componentContent = `export const ${nome} = () => {
  return (
    <div>
      <h1>${nome} component</h1>
    </div>
  );
};`;

    // Se styled components for solicitado
    if (styled) {
    console.log();

    // Template do componente principal
    let componentImports = `import React from "react";\n`;
    let componentContent = `export const ${nome} = () => {
  return (
    <div>
      <h1>${nome} component</h1>
    </div>
  );
};`;

    // Se styled components for solicitado
    if (options.styled) {
      componentImports += `import { Container } from "./styled";\n`;
      componentContent = `export const ${nome} = () => {
  return (
    <Container>
      <h1>${nome} component</h1>
    </Container>
  );
};`;

      // Criar arquivo styled
      const styledPath = path.join(dir, `styled.${jsExt}`);
      const styledTemplate = `import styled from "styled-components";

export const Container = styled.div\`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  
  h1 {
    color: #333;
    margin: 0;
  }
\`;
`;
      fs.writeFileSync(styledPath, styledTemplate);
      console.log(chalk.blue("ğŸ“¦"), chalk.bold("Styled Components:"), chalk.gray(styledPath));
    } 
    // Se emotion for solicitado
    else if (options.emotion) {
      componentImports += `import { Container } from "./styles";\n`;
      componentContent = `export const ${nome} = () => {
  return (
    <Container>
      <h1>${nome} component</h1>
    </Container>
  );
};`;

      // Criar arquivo emotion
      const emotionPath = path.join(dir, `styles.${jsExt}`);
      const emotionTemplate = `import styled from "@emotion/styled";

export const Container = styled.div\`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  
  h1 {
    color: #333;
    margin: 0;
  }
\`;
`;
      fs.writeFileSync(emotionPath, emotionTemplate);
      console.log(chalk.magenta("ğŸ˜Š"), chalk.bold("Emotion Styles:"), chalk.gray(emotionPath));
    } 
    // Se nÃ£o usar styled nem emotion, criar arquivo CSS normal
    else {
      componentImports += `import "./${nome}.css";\n`;
      
      const cssPath = path.join(dir, `${nome}.css`);
      const cssTemplate = `.${nome.toLowerCase()} {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
}

.${nome.toLowerCase()} h1 {
  color: #333;
  margin: 0;
}
`;
      fs.writeFileSync(cssPath, cssTemplate);
      componentContent = `export const ${nome} = () => {
  return (
    <div className="${nome.toLowerCase()}">
      <h1>${nome} component</h1>
    </div>
  );
};`;
      console.log(chalk.blue("ğŸ¨"), chalk.bold("CSS Stylesheet:"), chalk.gray(cssPath));
    }

    // Criar arquivo do componente
    const componentTemplate = `${componentImports}
${componentContent}
`;
    const filePath = path.join(dir, `${nome}.${ext}`);
    fs.writeFileSync(filePath, componentTemplate);
    console.log(chalk.green("âš›ï¸ "), chalk.bold("React Component:"), chalk.gray(filePath));

    // Se teste for solicitado
    if (options.test) {
      const testPath = path.join(dir, `${nome}.test.${ext}`);
      let testTemplate;
      
      if (options.styled || options.emotion) {
        const styledLibrary = options.styled ? "styled-components" : "@emotion/styled";
        testTemplate = `import React from "react";
import { render, screen } from "@testing-library/react";
import { ${nome} } from "./${nome}";

describe("${nome}", () => {
  it("deve renderizar o componente corretamente", () => {
    render(<${nome} />);
    expect(screen.getByText("${nome} component")).toBeInTheDocument();
  });

  it("deve renderizar o container styled (${options.emotion ? 'emotion' : 'styled-components'})", () => {
    render(<${nome} />);
    const element = screen.getByText("${nome} component").closest("div");
    expect(element).toBeInTheDocument();
  });
});
`;
      } else {
        testTemplate = `import React from "react";
import { render, screen } from "@testing-library/react";
import { ${nome} } from "./${nome}";

describe("${nome}", () => {
  it("deve renderizar o componente corretamente", () => {
    render(<${nome} />);
    expect(screen.getByText("${nome} component")).toBeInTheDocument();
  });

  it("deve aplicar as classes CSS corretas", () => {
    render(<${nome} />);
    const element = screen.getByText("${nome} component").closest("div");
    expect(element).toHaveClass("${nome.toLowerCase()}");
  });
});
`;
      }
      
      fs.writeFileSync(testPath, testTemplate);
      console.log(chalk.yellow("ğŸ§ª"), chalk.bold("Test File:"), chalk.gray(testPath));
    }

    // Criar arquivo index para facilitar importaÃ§Ã£o
    const indexPath = path.join(dir, `index.${jsExt}`);
    const indexTemplate = `export { ${nome} } from "./${nome}";
`;
    fs.writeFileSync(indexPath, indexTemplate);
    console.log(chalk.cyan("ğŸ“‹"), chalk.bold("Index File:"), chalk.gray(indexPath));

    // Banner de sucesso
    console.log();
    console.log(chalk.green('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
    console.log(chalk.green('â•‘'), chalk.bold.white(`âœ… Componente ${nome} criado com sucesso!`).padEnd(58), chalk.green('â•‘'));
    console.log(chalk.green('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
    
    // Resumo do que foi criado
    console.log();
    console.log(chalk.bold.white("ğŸ“ Arquivos criados:"));
    
    const createdFiles = [];
    createdFiles.push(`   ${chalk.green("âš›ï¸")}  ${nome}.${ext}`);
    
    if (options.styled) {
      createdFiles.push(`   ${chalk.blue("ï¿½")}  styled.${jsExt}`);
    } else if (options.emotion) {
      createdFiles.push(`   ${chalk.magenta("ğŸ˜Š")}  styles.${jsExt}`);
    } else {
      createdFiles.push(`   ${chalk.blue("ğŸ¨")}  ${nome}.css`);
    }
    
    createdFiles.push(`   ${chalk.cyan("ğŸ“‹")}  index.${jsExt}`);
    
    if (options.test) {
      createdFiles.push(`   ${chalk.yellow("ğŸ§ª")}  ${nome}.test.${ext}`);
    }
    
    createdFiles.forEach(file => console.log(file));
    
    // InstruÃ§Ãµes de uso
    console.log();
    console.log(chalk.bold.white("ğŸš€ Como usar:"));
    
    // Calcular o caminho relativo correto para importaÃ§Ã£o
    const componentPath = path.relative(process.cwd(), dir);
    const importPath = componentPath === nome ? `./${nome}` : `./${componentPath}`;
    
    console.log(`   ${chalk.gray("import")} ${chalk.white("{")} ${chalk.yellow(nome)} ${chalk.white("}")} ${chalk.gray("from")} ${chalk.green(`"${importPath}"`)}${chalk.gray(";")}`);
    console.log();
    console.log(chalk.gray(`ğŸ’¡ Dica: Componente criado em ${chalk.white(componentPath)}`));
    console.log(chalk.gray("ğŸ’¡ O arquivo index.js permite importar diretamente da pasta!"));
    console.log();
  });

program.parse();
