#!/usr/bin/env node

import { Command } from "commander";
import fs from "fs";
import path from "path";
import chalk from "chalk";
import inquirer from "inquirer";

const program = new Command();

// Função para modo interativo
async function interactiveMode() {
  console.log(chalk.cyan('╔══════════════════════════════════════════════════════════════╗'));
  console.log(chalk.cyan('║'), chalk.bold.white('🎯 Modo Interativo - Criador de Componentes').padEnd(58), chalk.cyan('║'));
  console.log(chalk.cyan('╚══════════════════════════════════════════════════════════════╝'));
  console.log();
  
  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'nome',
      message: '📝 Qual o nome do componente?',
      validate: (input) => {
        if (!input || input.trim() === '') {
          return '❌ O nome do componente é obrigatório!';
        }
        if (!/^[A-Z][a-zA-Z0-9]*$/.test(input.trim())) {
          return '❌ O nome deve começar com letra maiúscula e conter apenas letras e números!';
        }
        return true;
      }
    },
    {
      type: 'input',
      name: 'path',
      message: '📁 Em qual pasta criar o componente? (Enter para raiz)',
      default: '.',
      validate: (input) => {
        // Validação básica de caminho
        if (input.includes('..') && !input.startsWith('./')) {
          return '❌ Use caminhos relativos que comecem com "./"';
        }
        return true;
      }
    },
    {
      type: 'confirm',
      name: 'useTypeScript',
      message: '🔷 Usar TypeScript?',
      default: false
    },
    {
      type: 'list',
      name: 'styleType',
      message: '🎨 Qual tipo de estilização usar?',
      choices: [
        { name: '📄 CSS tradicional', value: 'css' },
        { name: '💅 Styled Components', value: 'styled' },
        { name: '😊 Emotion', value: 'emotion' }
      ],
      default: 'css'
    },
    {
      type: 'confirm',
      name: 'includeTests',
      message: '🧪 Incluir arquivo de testes?',
      default: false
    }
  ]);

  return {
    nome: answers.nome.trim(),
    ts: answers.useTypeScript,
    styled: answers.styleType === 'styled',
    emotion: answers.styleType === 'emotion',
    path: answers.path,
    test: answers.includeTests
  };
}

program
  .name("create-component")
  .description("🚀 CLI para gerar componentes React com suporte a CSS, Styled Components, Emotion e testes")
  .version("1.0.0")
  .helpOption('-h, --help', 'mostrar informações de ajuda');

program
  .argument("[nome]", "Nome do componente (opcional no modo interativo)")
  .option("-t, --ts", "Gerar componente em TypeScript", false)
  .option("-s, --styled", "Gerar arquivo de styled components", false)
  .option("-e, --emotion", "Gerar arquivo de emotion styled", false)
  .option("-p, --path <caminho>", "Caminho onde criar o componente (padrão: diretório atual)", ".")
  .option("-i, --interactive", "Modo interativo com perguntas", false)
  .option("--test", "Gerar arquivo de teste", false)
  .addHelpText('before', `
${chalk.cyan('╔══════════════════════════════════════════════════════════════╗')}
${chalk.cyan('║')}  ${chalk.bold.white('🎨 CLI React Components Generator')}                           ${chalk.cyan('║')}
${chalk.cyan('║')}  ${chalk.gray('Ferramenta para criar componentes React rapidamente')}         ${chalk.cyan('║')}
${chalk.cyan('╚══════════════════════════════════════════════════════════════╝')}
`)
  .addHelpText('after', `
${chalk.yellow('💡 EXEMPLOS DE USO:')}
  ${chalk.green('$')} ${chalk.white('create-component --interactive')}            ${chalk.gray('# 🎯 Modo interativo com perguntas')}
  ${chalk.green('$')} ${chalk.white('create-component -i')}                       ${chalk.gray('# 🎯 Modo interativo (alias)')}
  ${chalk.green('$')} ${chalk.white('create-component Button')}                    ${chalk.gray('# 📄 Componente básico na raiz')}
  ${chalk.green('$')} ${chalk.white('create-component Modal --ts')}                ${chalk.gray('# 🔷 Componente TypeScript')}
  ${chalk.green('$')} ${chalk.white('create-component Header --styled')}           ${chalk.gray('# 💅 Componente com Styled Components')}
  ${chalk.green('$')} ${chalk.white('create-component Sidebar --emotion')}         ${chalk.gray('# 😊 Componente com Emotion')}
  ${chalk.green('$')} ${chalk.white('create-component Card --path ./src')}         ${chalk.gray('# 📁 Criar em pasta específica')}
  ${chalk.green('$')} ${chalk.white('create-component Nav -p ./src/components')}   ${chalk.gray('# 📁 Usar alias -p')}
  ${chalk.green('$')} ${chalk.white('create-component Form --ts --test --path ./src/forms')} ${chalk.gray('# 🚀 Completo com caminho')}

${chalk.yellow('📁 ESTRUTURAS DE CAMINHO:')}
  ${chalk.blue('Sem --path:')}       ${chalk.white('./NomeComponente/')} ${chalk.gray('(na raiz do projeto)')}
  ${chalk.blue('--path ./src:')}     ${chalk.white('./src/NomeComponente/')} ${chalk.gray('(dentro de src)')}
  ${chalk.blue('--path ./components:')} ${chalk.white('./components/NomeComponente/')} ${chalk.gray('(dentro de components)')}
  ${chalk.blue('Caminhos relativos:')} ${chalk.gray('Sempre relativos ao diretório atual')}

${chalk.yellow('📁 ESTRUTURAS GERADAS:')}
  ${chalk.blue('Básico:')}           ${chalk.white('NomeComponente/')} ${chalk.gray('NomeComponente.jsx + NomeComponente.css + index.js')}
  ${chalk.blue('--styled:')}         ${chalk.white('NomeComponente/')} ${chalk.gray('NomeComponente.jsx + styled.js + index.js')}
  ${chalk.blue('--emotion:')}        ${chalk.white('NomeComponente/')} ${chalk.gray('NomeComponente.jsx + styles.js + index.js')}
  ${chalk.blue('--test:')}           ${chalk.gray('Adiciona')} ${chalk.white('NomeComponente.test.jsx')} ${chalk.gray('com testes básicos')}
  ${chalk.blue('--ts:')}             ${chalk.gray('Usa extensões')} ${chalk.white('.tsx/.ts')} ${chalk.gray('em vez de')} ${chalk.white('.jsx/.js')}

${chalk.yellow('⚠️  NOTAS IMPORTANTES:')}
  ${chalk.red('•')} Não é possível usar ${chalk.white('--styled')} e ${chalk.white('--emotion')} juntos
  ${chalk.green('•')} Cada componente é criado em sua própria pasta
  ${chalk.green('•')} Arquivo ${chalk.white('index.js/ts')} é sempre criado para facilitar importações
  ${chalk.green('•')} Caminhos são criados automaticamente se não existirem
  ${chalk.green('•')} TypeScript (${chalk.white('--ts')}) funciona com todas as outras opções

${chalk.cyan('🔗 Para mais informações, visite:')} ${chalk.underline('https://github.com/seu-usuario/cli-react-components')}
`)
  .action(async (nome, options) => {
    let componentOptions;
    
    // Se modo interativo ou não há nome fornecido
    if (options.interactive || !nome) {
      componentOptions = await interactiveMode();
    } else {
      // Modo tradicional via flags
      // Verificar se o nome foi fornecido
      if (!nome || nome.trim() === '') {
        console.log(chalk.red.bold("❌ ERRO:"), chalk.red("Nome do componente é obrigatório"));
        console.log(chalk.gray("💡 Use"), chalk.cyan("'create-component --help'"), chalk.gray("para ver todas as opções"));
        console.log(chalk.gray("💡 Ou use"), chalk.cyan("'create-component --interactive'"), chalk.gray("para modo interativo"));
        return;
      }
      
      componentOptions = {
        nome: nome.trim(),
        ts: options.ts,
        styled: options.styled,
        emotion: options.emotion,
        path: options.path,
        test: options.test
      };
    }

    // Agora criar o componente com as opções escolhidas
    await createComponent(componentOptions);
  });

// Função para criar o componente
async function createComponent(options) {
    const { nome, ts, styled, emotion, path: customPath, test } = options;
    
    const ext = ts ? "tsx" : "jsx";
    const jsExt = ts ? "ts" : "js";
    
    // Resolver o caminho base (onde criar o componente)
    const basePath = path.resolve(process.cwd(), customPath || ".");
    const dir = path.join(basePath, nome);
    
    // Criar diretórios recursivamente se não existirem
    if (!fs.existsSync(basePath)) {
      fs.mkdirSync(basePath, { recursive: true });
      console.log(chalk.blue("📁"), chalk.bold("Diretório criado:"), chalk.gray(basePath));
    }
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Verificar se styled e emotion foram usados juntos
    if (styled && emotion) {
      console.log(chalk.red.bold("❌ ERRO:"), chalk.red("Não é possível usar"), chalk.yellow("styled"), chalk.red("e"), chalk.yellow("emotion"), chalk.red("juntos."));
      console.log(chalk.gray("💡 Escolha apenas uma das opções de estilização."));
      return;
    }

    // Banner de início
    console.log(chalk.cyan('╔══════════════════════════════════════════════════════════════╗'));
    console.log(chalk.cyan('║'), chalk.bold.white(`🎨 Criando componente: ${nome}`).padEnd(58), chalk.cyan('║'));
    
    // Mostrar o caminho onde será criado
    const relativePath = path.relative(process.cwd(), dir);
    console.log(chalk.cyan('║'), chalk.gray(`📁 Caminho: ${relativePath}`).padEnd(58), chalk.cyan('║'));
    console.log(chalk.cyan('╚══════════════════════════════════════════════════════════════╝'));
    console.log();

    // Template do componente principal
    let componentImports = `import React from "react";\n`;
    let componentContent = `export const ${nome} = () => {
  return (
    <div>
      <h1>${nome} component</h1>
    </div>
  );
};`;

    // Se styled components for solicitado
    if (styled) {
    console.log();

    // Template do componente principal
    let componentImports = `import React from "react";\n`;
    let componentContent = `export const ${nome} = () => {
  return (
    <div>
      <h1>${nome} component</h1>
    </div>
  );
};`;

    // Se styled components for solicitado
    if (options.styled) {
      componentImports += `import { Container } from "./styled";\n`;
      componentContent = `export const ${nome} = () => {
  return (
    <Container>
      <h1>${nome} component</h1>
    </Container>
  );
};`;

      // Criar arquivo styled
      const styledPath = path.join(dir, `styled.${jsExt}`);
      const styledTemplate = `import styled from "styled-components";

export const Container = styled.div\`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  
  h1 {
    color: #333;
    margin: 0;
  }
\`;
`;
      fs.writeFileSync(styledPath, styledTemplate);
      console.log(chalk.blue("📦"), chalk.bold("Styled Components:"), chalk.gray(styledPath));
    } 
    // Se emotion for solicitado
    else if (options.emotion) {
      componentImports += `import { Container } from "./styles";\n`;
      componentContent = `export const ${nome} = () => {
  return (
    <Container>
      <h1>${nome} component</h1>
    </Container>
  );
};`;

      // Criar arquivo emotion
      const emotionPath = path.join(dir, `styles.${jsExt}`);
      const emotionTemplate = `import styled from "@emotion/styled";

export const Container = styled.div\`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  
  h1 {
    color: #333;
    margin: 0;
  }
\`;
`;
      fs.writeFileSync(emotionPath, emotionTemplate);
      console.log(chalk.magenta("😊"), chalk.bold("Emotion Styles:"), chalk.gray(emotionPath));
    } 
    // Se não usar styled nem emotion, criar arquivo CSS normal
    else {
      componentImports += `import "./${nome}.css";\n`;
      
      const cssPath = path.join(dir, `${nome}.css`);
      const cssTemplate = `.${nome.toLowerCase()} {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
}

.${nome.toLowerCase()} h1 {
  color: #333;
  margin: 0;
}
`;
      fs.writeFileSync(cssPath, cssTemplate);
      componentContent = `export const ${nome} = () => {
  return (
    <div className="${nome.toLowerCase()}">
      <h1>${nome} component</h1>
    </div>
  );
};`;
      console.log(chalk.blue("🎨"), chalk.bold("CSS Stylesheet:"), chalk.gray(cssPath));
    }

    // Criar arquivo do componente
    const componentTemplate = `${componentImports}
${componentContent}
`;
    const filePath = path.join(dir, `${nome}.${ext}`);
    fs.writeFileSync(filePath, componentTemplate);
    console.log(chalk.green("⚛️ "), chalk.bold("React Component:"), chalk.gray(filePath));

    // Se teste for solicitado
    if (options.test) {
      const testPath = path.join(dir, `${nome}.test.${ext}`);
      let testTemplate;
      
      if (options.styled || options.emotion) {
        const styledLibrary = options.styled ? "styled-components" : "@emotion/styled";
        testTemplate = `import React from "react";
import { render, screen } from "@testing-library/react";
import { ${nome} } from "./${nome}";

describe("${nome}", () => {
  it("deve renderizar o componente corretamente", () => {
    render(<${nome} />);
    expect(screen.getByText("${nome} component")).toBeInTheDocument();
  });

  it("deve renderizar o container styled (${options.emotion ? 'emotion' : 'styled-components'})", () => {
    render(<${nome} />);
    const element = screen.getByText("${nome} component").closest("div");
    expect(element).toBeInTheDocument();
  });
});
`;
      } else {
        testTemplate = `import React from "react";
import { render, screen } from "@testing-library/react";
import { ${nome} } from "./${nome}";

describe("${nome}", () => {
  it("deve renderizar o componente corretamente", () => {
    render(<${nome} />);
    expect(screen.getByText("${nome} component")).toBeInTheDocument();
  });

  it("deve aplicar as classes CSS corretas", () => {
    render(<${nome} />);
    const element = screen.getByText("${nome} component").closest("div");
    expect(element).toHaveClass("${nome.toLowerCase()}");
  });
});
`;
      }
      
      fs.writeFileSync(testPath, testTemplate);
      console.log(chalk.yellow("🧪"), chalk.bold("Test File:"), chalk.gray(testPath));
    }

    // Criar arquivo index para facilitar importação
    const indexPath = path.join(dir, `index.${jsExt}`);
    const indexTemplate = `export { ${nome} } from "./${nome}";
`;
    fs.writeFileSync(indexPath, indexTemplate);
    console.log(chalk.cyan("📋"), chalk.bold("Index File:"), chalk.gray(indexPath));

    // Banner de sucesso
    console.log();
    console.log(chalk.green('╔══════════════════════════════════════════════════════════════╗'));
    console.log(chalk.green('║'), chalk.bold.white(`✅ Componente ${nome} criado com sucesso!`).padEnd(58), chalk.green('║'));
    console.log(chalk.green('╚══════════════════════════════════════════════════════════════╝'));
    
    // Resumo do que foi criado
    console.log();
    console.log(chalk.bold.white("📁 Arquivos criados:"));
    
    const createdFiles = [];
    createdFiles.push(`   ${chalk.green("⚛️")}  ${nome}.${ext}`);
    
    if (options.styled) {
      createdFiles.push(`   ${chalk.blue("�")}  styled.${jsExt}`);
    } else if (options.emotion) {
      createdFiles.push(`   ${chalk.magenta("😊")}  styles.${jsExt}`);
    } else {
      createdFiles.push(`   ${chalk.blue("🎨")}  ${nome}.css`);
    }
    
    createdFiles.push(`   ${chalk.cyan("📋")}  index.${jsExt}`);
    
    if (options.test) {
      createdFiles.push(`   ${chalk.yellow("🧪")}  ${nome}.test.${ext}`);
    }
    
    createdFiles.forEach(file => console.log(file));
    
    // Instruções de uso
    console.log();
    console.log(chalk.bold.white("🚀 Como usar:"));
    
    // Calcular o caminho relativo correto para importação
    const componentPath = path.relative(process.cwd(), dir);
    const importPath = componentPath === nome ? `./${nome}` : `./${componentPath}`;
    
    console.log(`   ${chalk.gray("import")} ${chalk.white("{")} ${chalk.yellow(nome)} ${chalk.white("}")} ${chalk.gray("from")} ${chalk.green(`"${importPath}"`)}${chalk.gray(";")}`);
    console.log();
    console.log(chalk.gray(`💡 Dica: Componente criado em ${chalk.white(componentPath)}`));
    console.log(chalk.gray("💡 O arquivo index.js permite importar diretamente da pasta!"));
    console.log();
  });

program.parse();
